# igraphパッケージの読み込み
library(igraph)
source("../src/functions_network_controllability.R")
# モデルネットワークを例にする。
g <- static.power.law.game(50,70,2.1,2.1)
# ネットワークの表示
plot(g, vertex.size=10, edge.arrow.size=0.5, vertex.label=NA)
mds <- get_mds_matching(g, relax = F)
# @param relax: 論理値，バイナリ整数計画問題を線形計画緩和するかどうか。デフォルトはF（しない）。
# 最小ドライバーノード集合のサイズ（ドライバノードの数）
mds[[1]]
# ドライバノードメンバーシップ: ドライバノードである (1) でない (0)
mds[[2]]
# マッチングリンクのメンバーシップ: マッチングリンクである (1) ない (0)
mds[[3]]
# ドライバノードはオレンジで色付けされる。
plot(g, vertex.size=10, edge.arrow.size=0.5, vertex.label=NA, vertex.color=c("white","orange")[mds[[2]]+1])
# igraphパッケージの読み込み
library(igraph)
library(lpSolve) # 混合整数線形計画法ためのパッケージ
# igraphパッケージの読み込み
library(igraph)
library(lpSolve) # 混合整数線形計画法ためのパッケージ
source("../src/functions_network_controllability.R")
# モデルネットワークを例にする。
g <- static.power.law.game(50,70,2.1,2.1)
# ネットワークの表示
plot(g, vertex.size=10, edge.arrow.size=0.5, vertex.label=NA)
mds <- get_mds_matching(g, relax = F)
# @param relax: 論理値，バイナリ整数計画問題を線形計画緩和するかどうか。デフォルトはF（しない）。
# 最小ドライバーノード集合のサイズ（ドライバノードの数）
mds[[1]]
# ドライバノードメンバーシップ: ドライバノードである (1) でない (0)
mds[[2]]
# マッチングリンクのメンバーシップ: マッチングリンクである (1) ない (0)
mds[[3]]
V(g)$node_class <- node_classification_controllability(g, get_mds = get_mds_matching, relax = F)
# @param relax: 論理値，バイナリ整数計画問題を線形計画緩和するかどうか。デフォルトはF（しない）。
# @param get_mds: 最小ノード集合を得るための関数
# 色付けの準備
V(g)$color[V(g)$node_class=="dispensable"] <- "gray"
V(g)$color[V(g)$node_class=="neutral"] <- "skyblue"
V(g)$color[V(g)$node_class=="indispensable"] <- "pink"
# ネットワークを描画
# 灰：不必要（dispensable）ノード，水色：中立（neutral）ノード，桃：不可欠（indispensable）ノード
plot(g, vertex.size=10, edge.arrow.size=0.5, vertex.label=NA)
# igraphパッケージの読み込み
library(igraph)
library(lpSolve) # 混合整数線形計画法ためのパッケージ
source("../src/functions_network_controllability.R")
# モデルネットワークを例にする。
g <- static.power.law.game(50,70,2.1,2.1)
# ネットワークの表示
plot(g, vertex.size=10, edge.arrow.size=0.5, vertex.label=NA)
mds <- get_mds_domination(g, relax = F)
# @param relax: 論理値，バイナリ整数計画問題を線形計画緩和するかどうか。デフォルトはF（しない）。
# 最小支配集合のサイズ（ドライバ（支配）ノードの数）
mds[[1]]
# ドライバノードメンバーシップ: ドライバノードである (1) でない (0)
mds[[2]]
V(g)$node_class <- node_classification_controllability(g, get_mds = get_mds_domination, relax = F)
# @param relax: 論理値，バイナリ整数計画問題を線形計画緩和するかどうか。デフォルトはF（しない）。
# @param get_mds: 最小ノード集合を得るための関数
# 色付けの準備
V(g)$color[V(g)$node_class=="dispensable"] <- "gray"
V(g)$color[V(g)$node_class=="neutral"] <- "skyblue"
V(g)$color[V(g)$node_class=="indispensable"] <- "pink"
# ネットワークを描画
# 灰：不必要（dispensable）ノード，水色：中立（neutral）ノード，桃：不可欠（indispensable）ノード
plot(g, vertex.size=10, edge.arrow.size=0.5, vertex.label=NA)
# igraphパッケージの読み込み
library(igraph)
# igraphパッケージの読み込み
library(igraph)
library(lpSolve) # 混合整数線形計画法ためのパッケージ
source("../src/functions_network_controllability.R")
# エッジリストの読み込み
d <- read.csv("../data/breast_cancer_directed_ppi_Kanhaiya_etal_2017.csv")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=T),remove.multiple=T,remove.loops=T)
# 最大強連結成分の取得（本来は不必要だが，小さなネットワークを得るために実行）
cls <- clusters(g,"strong")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
V(g)$node_class <- node_classification_controllability(g, get_mds = get_mds_matching, relax = F)
# @param relax: 論理値，バイナリ整数計画問題を線形計画緩和するかどうか。デフォルトはF（しない）。
drug_target <- read.csv("../data/drug_target_proteins.csv", stringsAsFactors=F)
# ノードがDrug targetかそうでないかをまとめる。
V(g)$target <- ifelse(V(g)$name %in% drug_target$target, "target", "nontarget")
# 混同行列の作成
conf_table <- table(V(g)$node_class,V(g)$target)
# 混同行列の出力
conf_table
target_ratio <- conf_table[,"target"] / apply(conf_table,1,sum)
target_ratio
barplot(target_ratio,col=c("skyblue","pink","gray"))
fisher.test(conf_table)
