library(Matrix)
library(Hmisc)
library(ppcor)
library(SpiecEasi)
# P値で閾値化するための関数を読み込む
source("../src/thresholding.p.value.R")
# ランダム行列理論で閾値化するための関数を読み込む
source("../src/thresholding.RMT.R")
# その他必要な関数を読み込む
source("../src/correlation_utils.R")
# 人工的な正解ネットワークを作成し，そのネットワーク構造に従って分散共分散行列を作る。
data <- generate_covariance_matrix(nn=30, k_ave=4, type.network="sf")
# @param nn ノード数
# @param k_ave 平均次数
# @param type.network ネットワーク構造
#               random: ランダムネットワーク
#                   sf: スケールフリーネットワーク
#                   sw: スモールワールドネットワーク
# 正解ネットワークのグラフオブジェクトを得る。
g_real <- data[[1]]
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x_abs <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# 相対データに変換
x_rel <- x_abs / apply(x_abs,1,sum)
# ピアソン相関
cormtx_abs <- rcorr(x_abs, type="pearson")
cormtx_rel <- rcorr(x_rel, type="pearson")
# 相関係数行列の取得
rmtx_abs <- cormtx_abs$r
rmtx_rel <- cormtx_rel$r
# P値行列の取得
pmtx_abs <- cormtx_abs$P
pmtx_rel <- cormtx_rel$P
g_pred_abs <- thresholding.p.value(pmtx_abs, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_abs)
g_pred_rel <- thresholding.p.value(pmtx_rel, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_rel)
g_pred_abs <- thresholding.RMT(rmtx_abs)
network_prediction_performance(g_real, g_pred_abs)
g_pred_rel <- thresholding.RMT(rmtx_rel)
network_prediction_performance(g_real, g_pred_rel)
spboot <- sparccboot(x_abs, R=100, ncpus=2)
# @param R Bootstrap数
# @param ncpus 並列に使うCPUの数
# pval.sparccboot(spboot)$pvalsはP値行列の上三角行列しか返さないので変換する。
n <- dim(x_abs)[[2]]
m <- matrix(0, n, n)
m[upper.tri(m)] <- pval.sparccboot(spboot)$pvals
m <- m + t(m)
diag(m) <- 1
m <- ifelse(is.nan(m),1,m)
# 閾値化と評価
g_pred_rel <- thresholding.p.value(m, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_rel)
# 相関係数行列の作成
n <- dim(x_rel)[[2]]
m <- matrix(0, n, n)
m[upper.tri(m)] <- pval.sparccboot(spboot)$cors
m <- m + t(m)
diag(m) <- 1
m <- ifelse(is.nan(m),0,m)
# 閾値化と評価
g_pred_rel <- thresholding.RMT(m)
network_prediction_performance(g_real, g_pred_rel)
se <- spiec.easi(x_abs, method="mb")
g_pred_rel <- adj2igraph(getRefit(se))
network_prediction_performance(g_real, g_pred_rel)
library(igraph)
d <- read.table("../data/eco_EM+TCA.txt")
# 有向ネットワークで読み込む
g <- graph.data.frame(d, directed=T)
# 多重エッジや自己ループを削除する。
g <- simplify(g, remove.multiple=T, remove.loops=T)
g
plot(g)
plot(g,
vertex.size=8, #ノードの大きさ
vertex.shape="square", #ノードの形 names(igraph:::.igraph.shapes) で使える形を確認できる
vertex.label=V(g)$name, #ノード属性nameをノードラベルにする。
vertex.color="lightblue",
vertex.label.color="gray50", #ノードのラベルの色
#ノードのラベルのスタイル 1: 普通, 2: 太字, 3: 斜体, 4: 太字斜体, 5: ギリシャ文字
vertex.label.font=2,
vertex.frame.color="white", #ノードの枠の色
vertex.label.cex=0.8, #ノードラベルの文字サイズ
edge.width=2, #エッジ属性weightをエッジの太さとする
edge.arrow.size=0.5, # 矢印の大きさ
edge.color="gray80", #エッジの色
# ネットワークのレイアウト手法 help(layout,igraph)で使える手法を確認できる
layout=layout.fruchterman.reingold #ネットワークのレイアウト手法
)
g <- as.undirected(g)
g
g <- delete_vertices(g, c("F6P", "GAP"))
g <- delete_edges(g, c("2PG|3PG", "3PG|BPG"))
# ネットワークの描画
plot(g)
cls <- clusters(g, "weak")
# 結果
cls
plot(g, vertex.color=cls$membership)
# 最大連結成分に属さないノードを削除する
g <- delete_vertices(g, subset(V(g), cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
# ネットワークを描画
plot(g)
# igraphパッケージの読み込み
library(igraph)
library(gtools)
# エッジリストの読み込み
d <- read.table("../data/yeast_ppi_Batada_etal_2006.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 仮想的な重みを追加する（対数正規分布由来の乱数を与える）
E(g)$weight <- rlnorm(ecount(g))
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
vcount(g)
ecount(g)
deg <- degree(g)
deg
strength(g)
plot(0:max(deg), degree.distribution(g), xlab="k", ylab="P(k)", log="xy")
dist <- table(degree(g)) / sum(table(degree(g)))
-sum(dist * log(dist))
cc <- transitivity(g, type="local", isolates="zero")
transitivity(g, type="localaverage", isolates="zero")
# もしくは
mean(cc)
# 各ノードに対する重み付きクラスタ係数
wcc <- transitivity(g, type="weighted", isolates="zero")
# 平均重み付きクラスタ係数
mean(wcc)
assortativity.degree(g)
mean_distance(g)
# 距離行列を計算して
d_mtx <- distances(g, weights=E(g)$weight)
# 対角成分を除いた上三角行列の要素の平均を計算する
mean(d_mtx[upper.tri(d_mtx)])
dinv_mtx <- distances(g, weights=NA)**-1
# d_mtx <- distances(g, weights=E(g)$weight)**-1 # 重み付きネットワークなら
diag(dinv_mtx) <- 0
# 各ノードに対する大域効率性
nodal_global_efficiency <- apply(dinv_mtx,1,sum) / (vcount(g) - 1)
# 全体的（平均的な）大域効率性
ave_global_efficiency <- mean(nodal_global_efficiency)
# 各ノードに対する局所効率性
nodal_local_efficiency <- c()
for(i in 1:vcount(g)){
nei_idx <- as.vector(neighbors(g,i)) # 隣接ノードのインデックスを取得
num_nei <- length(nei_idx)
if(num_nei > 1) {
nodal_local_efficiency <- c(nodal_local_efficiency, sum(dinv_mtx[permutations(num_nei,2,nei_idx)]) / num_nei / (num_nei - 1))
} else {
nodal_local_efficiency <- c(nodal_local_efficiency,0)
}
}
# 全体的（平均的な）局所効率性
ave_local_efficiency <- mean(nodal_local_efficiency)
# igraphパッケージの読み込み
library(igraph)
# igraphパッケージの読み込み
library(igraph)
d <- read.table("../data/eco_EM+TCA.txt")
# 有向ネットワークで読み込む
g <- graph.data.frame(d, directed=T)
# 多重エッジや自己ループを削除する。
g <- simplify(g, remove.multiple=T, remove.loops=T)
paths <- all_shortest_paths(g, "D-Glucose","2-Oxoglutarate",mode="out")
V(g)[paths$res[[1]]]
E(g, path=paths$res[[1]])
# エッジを全部灰色にする
E(g)$color <- "grey"
# 最短経路に含まれるエッジを赤色にする。
E(g, path=paths$res[[1]])$color <- "red"
# 最短経路に含まれるエッジを太くする。
E(g,path=paths$res[[1]])$width <- 3
plot(g,
vertex.label=V(g)$name,
# 最短経路に含まれるノードは赤，そうでないものは白にする。
vertex.color=c("red","white")[ifelse(V(g)$name %in% V(g)[paths$res[[1]]]$name,1,2)],
vertex.size=10,
edge.arrow.size=0.5
)
library(Matrix)
library(Hmisc)
library(ppcor)
library(bootnet)
# P値で閾値化するための関数を読み込む
source("../src/thresholding.p.value.R")
# ランダム行列理論で閾値化するための関数を読み込む
source("../src/thresholding.RMT.R")
# その他必要な関数を読み込む
source("../src/correlation_utils.R")
# 人工的な正解ネットワークを作成し，そのネットワーク構造に従って分散共分散行列を作る。
data <- generate_covariance_matrix(nn=30, k_ave=4, type.network="sf")
# @param nn ノード数
# @param k_ave 平均次数
# @param type.network ネットワーク構造
#               random: ランダムネットワーク
#                   sf: スケールフリーネットワーク
#                   sw: スモールワールドネットワーク
# 正解ネットワークのグラフオブジェクトを得る。
g_real <- data[[1]]
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# ピアソン相関の場合
cormtx <- rcorr(x, type="pearson")
# スピアマン相関の場合
#cormtx <- rcorr(x, type="spearman")
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="bonferroni")
# 相関係数行列の取得
rmtx <- cormtx$r
# P値行列の取得
pmtx <- cormtx$P
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="none")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="bonferroni")
network_prediction_performance(g_real, g_pred)
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# ピアソン相関の場合
cormtx <- rcorr(x, type="pearson")
# スピアマン相関の場合
#cormtx <- rcorr(x, type="spearman")
# 相関係数行列の取得
rmtx <- cormtx$r
# P値行列の取得
pmtx <- cormtx$P
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="none")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="bonferroni")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="lfdr")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.RMT(rmtx)
network_prediction_performance(g_real, g_pred)
pcormtx <- pcor(x)
pmtx_pcor <- pcormtx$p.value
g_pred <- thresholding.p.value(pmtx_pcor, p.th=0.05, method="lfdr")
network_prediction_performance(g_real, g_pred)
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
pcormtx <- pcor(x)
# 人工的な正解ネットワークを作成し，そのネットワーク構造に従って分散共分散行列を作る。
data <- generate_covariance_matrix(nn=30, k_ave=4, type.network="sf")
# @param nn ノード数
# @param k_ave 平均次数
# @param type.network ネットワーク構造
#               random: ランダムネットワーク
#                   sf: スケールフリーネットワーク
#                   sw: スモールワールドネットワーク
# 正解ネットワークのグラフオブジェクトを得る。
g_real <- data[[1]]
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
pcormtx <- pcor(x)
pcormtx <- pcor(x)
pmtx_pcor <- pcormtx$p.value
g_pred <- thresholding.p.value(pmtx_pcor, p.th=0.05, method="lfdr")
network_prediction_performance(g_real, g_pred)
# 人工的な正解ネットワークを作成し，そのネットワーク構造に従って分散共分散行列を作る。
data <- generate_covariance_matrix(nn=30, k_ave=4, type.network="sf")
# @param nn ノード数
# @param k_ave 平均次数
# @param type.network ネットワーク構造
#               random: ランダムネットワーク
#                   sf: スケールフリーネットワーク
#                   sw: スモールワールドネットワーク
# 正解ネットワークのグラフオブジェクトを得る。
g_real <- data[[1]]
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
pcormtx <- pcor(x)
pmtx_pcor <- pcormtx$p.value
g_pred <- thresholding.p.value(pmtx_pcor, p.th=0.05, method="lfdr")
network_prediction_performance(g_real, g_pred)
rmtx_pcor <- pcormtx$estimate
g_pred <- thresholding.RMT(rmtx_pcor)
network_prediction_performance(g_real, g_pred)
# ピアソン相関の場合
cormtx <- rcorr(x, type="pearson")
# スピアマン相関の場合
#cormtx <- rcorr(x, type="spearman")
# 相関係数行列の取得
rmtx <- cormtx$r
# P値行列の取得
pmtx <- cormtx$P
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="none")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="bonferroni")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.p.value(pmtx, p.th=0.05, method="lfdr")
network_prediction_performance(g_real, g_pred)
g_pred <- thresholding.RMT(rmtx)
network_prediction_performance(g_real, g_pred)
pcormtx <- pcor(x)
pmtx_pcor <- pcormtx$p.value
g_pred <- thresholding.p.value(pmtx_pcor, p.th=0.05, method="lfdr")
network_prediction_performance(g_real, g_pred)
rmtx_pcor <- pcormtx$estimate
g_pred <- thresholding.RMT(rmtx_pcor)
network_prediction_performance(g_real, g_pred)
net <- estimateNetwork(x, default="LoGo")
boots <- bootnet(net, nBoots=100, nCores=2)
net_th <- bootThreshold(boots, alpha = 0.2)
g_pred <- graph.adjacency(ifelse(abs(net_th$graph)>0, 1, 0),mode="undirected",weighted=NULL)
network_prediction_performance(g_real, g_pred)
library(devtools)
install_github("zdk123/SpiecEasi")
library(devtools)
install_github("zdk123/SpiecEasi")
library(devtools)
install_github("zdk123/SpiecEasi")
library(Matrix)
library(Hmisc)
library(ppcor)
library(SpiecEasi)
# P値で閾値化するための関数を読み込む
source("../src/thresholding.p.value.R")
# ランダム行列理論で閾値化するための関数を読み込む
source("../src/thresholding.RMT.R")
# その他必要な関数を読み込む
source("../src/correlation_utils.R")
# 人工的な正解ネットワークを作成し，そのネットワーク構造に従って分散共分散行列を作る。
data <- generate_covariance_matrix(nn=30, k_ave=4, type.network="sf")
# @param nn ノード数
# @param k_ave 平均次数
# @param type.network ネットワーク構造
#               random: ランダムネットワーク
#                   sf: スケールフリーネットワーク
#                   sw: スモールワールドネットワーク
# 正解ネットワークのグラフオブジェクトを得る。
g_real <- data[[1]]
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x_abs <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# 相対データに変換
x_rel <- x_abs / apply(x_abs,1,sum)
# ピアソン相関
cormtx_abs <- rcorr(x_abs, type="pearson")
cormtx_rel <- rcorr(x_rel, type="pearson")
# 相関係数行列の取得
rmtx_abs <- cormtx_abs$r
rmtx_rel <- cormtx_rel$r
# P値行列の取得
pmtx_abs <- cormtx_abs$P
pmtx_rel <- cormtx_rel$P
g_pred_abs <- thresholding.p.value(pmtx_abs, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_abs)
g_pred_rel <- thresholding.p.value(pmtx_rel, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_rel)
g_pred_rel <- thresholding.RMT(rmtx_rel)
network_prediction_performance(g_real, g_pred_rel)
spboot <- sparccboot(x_abs, R=100, ncpus=2)
# @param R Bootstrap数
# @param ncpus 並列に使うCPUの数
# pval.sparccboot(spboot)$pvalsはP値行列の上三角行列しか返さないので変換する。
n <- dim(x_abs)[[2]]
m <- matrix(0, n, n)
m[upper.tri(m)] <- pval.sparccboot(spboot)$pvals
m <- m + t(m)
diag(m) <- 1
m <- ifelse(is.nan(m),1,m)
# 閾値化と評価
g_pred_rel <- thresholding.p.value(m, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_rel)
# 相関係数行列の作成
n <- dim(x_rel)[[2]]
m <- matrix(0, n, n)
m[upper.tri(m)] <- pval.sparccboot(spboot)$cors
m <- m + t(m)
diag(m) <- 1
m <- ifelse(is.nan(m),0,m)
# 閾値化と評価
g_pred_rel <- thresholding.RMT(m)
network_prediction_performance(g_real, g_pred_rel)
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method="mb")
x_abs
se <- spiec.easi(x_abs, method="mb")
x_abs
se <- spiec.easi(as.data.grame(x_abs), method="mb")
se <- spiec.easi(as.data.frame(x_abs), method="mb")
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method="mb")
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x_abs <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# 相対データに変換
x_rel <- x_abs / apply(x_abs,1,sum)
se <- spiec.easi(x_abs, method="mb")
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x_abs <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# 相対データに変換
x_rel <- x_abs / apply(x_abs,1,sum)
x_abs
spiec.easi(x_abs, method="mb")
spiec.easi(x_abs, method="mb")
spiec.easi(x_abs)
spiec.easi(x_abs, method="mb")
x_abs
se <- spiec.easi(round(x_abs), method="mb")
se <- spiec.easi(round(x_abs), method="mb")
round(x_abs)
se <- spiec.easi(round(x_abs), method="mb")
dim(x_abs)
x_abs
se <- spiec.easi(round(x_abs), method="mb")
x_abs[1:10,1:10]
se <- spiec.easi(x_abs[1:10], method="mb")
se <- spiec.easi(x_abs[1:10,1:10], method="mb")
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs,method="mb")
library(Matrix)
library(Hmisc)
library(ppcor)
library(SpiecEasi)
# P値で閾値化するための関数を読み込む
source("../src/thresholding.p.value.R")
# ランダム行列理論で閾値化するための関数を読み込む
source("../src/thresholding.RMT.R")
# その他必要な関数を読み込む
source("../src/correlation_utils.R")
# 人工的な正解ネットワークを作成し，そのネットワーク構造に従って分散共分散行列を作る。
data <- generate_covariance_matrix(nn=30, k_ave=4, type.network="sf")
# @param nn ノード数
# @param k_ave 平均次数
# @param type.network ネットワーク構造
#               random: ランダムネットワーク
#                   sf: スケールフリーネットワーク
#                   sw: スモールワールドネットワーク
# 正解ネットワークのグラフオブジェクトを得る。
g_real <- data[[1]]
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x_abs <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# 相対データに変換
x_rel <- x_abs / apply(x_abs,1,sum)
se <- spiec.easi(x_abs,method="mb")
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method='mb')
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method='mb')
library(Matrix)
library(Hmisc)
library(ppcor)
library(SpiecEasi)
# P値で閾値化するための関数を読み込む
source("../src/thresholding.p.value.R")
# ランダム行列理論で閾値化するための関数を読み込む
source("../src/thresholding.RMT.R")
# その他必要な関数を読み込む
source("../src/correlation_utils.R")
# 人工的な正解ネットワークを作成し，そのネットワーク構造に従って分散共分散行列を作る。
data <- generate_covariance_matrix(nn=30, k_ave=4, type.network="sf")
# @param nn ノード数
# @param k_ave 平均次数
# @param type.network ネットワーク構造
#               random: ランダムネットワーク
#                   sf: スケールフリーネットワーク
#                   sw: スモールワールドネットワーク
# 正解ネットワークのグラフオブジェクトを得る。
g_real <- data[[1]]
# 分散共分散行列を得る。
x.cor <- data[[2]]
# 分散共分散行列に従い，多変量正規分布で相関した乱数をサンプル数300で作成する。
x_abs <- mvrnorm(300, rep(5,dim(x.cor)[[1]]), Sigma=nearPD(x.cor, corr = T, keepDiag = T)$mat)
# 相対データに変換
x_rel <- x_abs / apply(x_abs,1,sum)
se <- spiec.easi(x_abs, method='mb')
se <- spiec.easi(x_abs, method='mb')
se<-spiec.easi(x_abs, method='mb')
se <- spiec.easi(x_abs, method="mb")
se <- spiec.easi(x_abs, method="mb")
# ピアソン相関
cormtx_abs <- rcorr(x_abs, type="pearson")
cormtx_rel <- rcorr(x_rel, type="pearson")
# 相関係数行列の取得
rmtx_abs <- cormtx_abs$r
rmtx_rel <- cormtx_rel$r
# P値行列の取得
pmtx_abs <- cormtx_abs$P
pmtx_rel <- cormtx_rel$P
g_pred_abs <- thresholding.p.value(pmtx_abs, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_abs)
g_pred_rel <- thresholding.p.value(pmtx_rel, p.th=0.05, method="BH")
network_prediction_performance(g_real, g_pred_rel)
