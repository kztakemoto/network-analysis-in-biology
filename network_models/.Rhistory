g <- static.power.law.game(5000, 10000, 2.5)
# 次数の範囲（0から最大次数）
k <- 0:max(degree(g))
# 次数分布の描画
plot(k, degree.distribution(g), xlab="k", ylab="P(k)", log="xy")
# 理論線
f <- function(k,gamma){
return(k**(-gamma))
}
# 理論線の描画
lines(k, f(k, 2))
# モデルネットワークの生成
g <- static.power.law.game(5000, 10000, 2.5)
# 次数の範囲（0から最大次数）
k <- 0:max(degree(g))
# 次数分布の描画
plot(k, degree.distribution(g), xlab="k", ylab="P(k)", log="xy")
# モデルネットワークの生成
g <- static.power.law.game(5000, 10000, 2.5)
# 次数の範囲（0から最大次数）
k <- 0:max(degree(g))
# 次数分布の描画
plot(k, degree.distribution(g), xlab="k", ylab="P(k)", log="xy")
# static.power.law.game(N, L, gamma)。
# gamma = 1 + 1 / xi
g <- static.power.law.game(30, 60, 2.5)
# 描画
plot(g)
# static.power.law.game(N, L, gamma)。
# gamma = 1 + 1 / xi
g <- static.power.law.game(30, 60, 2.5)
# 描画
plot(g)
# static.power.law.game(N, L, gamma)。
# gamma = 1 + 1 / xi
g <- static.power.law.game(30, 60, 2.5, finite.size.correction = T)
# 描画
plot(g)
# モデルネットワークの生成
g <- static.power.law.game(5000, 10000, 2.5, finite.size.correction = T)
# 次数の範囲（0から最大次数）
k <- 0:max(degree(g))
# 次数分布の描画
plot(k, degree.distribution(g), xlab="k", ylab="P(k)", log="xy")
# モデルネットワークの生成
g <- static.power.law.game(5000, 10000, 2.5, finite.size.correction = T)
# 次数の範囲（0から最大次数）
k <- 0:max(degree(g))
# 次数分布の描画
plot(k, degree.distribution(g), xlab="k", ylab="P(k)", log="xy")
g_rand <- degree.sequence.game(deg, method="vl")
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 仮想的な重みを追加する（対数正規分布由来の乱数を与える）
E(g)$weight <- rlnorm(ecount(g))
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
# 次数のベクトルを取得
deg <- degree(g)
g_rand <- degree.sequence.game(deg, method="vl")
plot(degree(g), degree(g_rand))
plot(degree(g), degree(g_rand))
abline(0,1)
plot(degree(g), degree(g_rand), xlab="k in real network", ylab="k in model network")
abline(0,1)
plot(degree(g), degree(g_rand), xlab="k in real network", ylab="k in model network")
abline(0,1)
# 調査するネットワーク（のファイル名）の指定
files <- c("ecoli_regDB5.txt",
"protein_structure_1A6N_A.txt",
"protein_structure_1BKS_A.txt",
"protein_structure_2VIK_A.txt",
"ecoli_ppi_Hu_etal_2009.txt",
"yeast_ppi_Batada_etal_2006.txt",
"human_ppi_hippie_v2.2.txt",
"metabolic_ecoli.txt",
"metabolic_yeast.txt",
"metabolic_human.txt",
"human_structural_brain_network_Ardesch_2019.txt",
"human_functional_brain_network_1000_Functional_Connectomes.txt",
"marine_food_web_pnas_102_15_5443_01562.txt",
"terrestrial_food_web_caribbean.txt"
)
# それぞれのネットワークの指標を計算してデータフレームに格納
df <- data.frame()
for(file in files){
# エッジリストの読み込み
d <- read.table(paste("../data/",file,sep=""), header=F)
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d[1:2], directed=F), remove.multiple=T, remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
# ノード数
N <- vcount(g)
# 平均次数
k_ave <- mean(degree(g))
# 平均最短経路長
d_ave <- mean_distance(g)
# 平均クラスタ係数
c_ave <- transitivity(g,type="localaverage",isolates="zero")
# 表示
df <- rbind(df, c(file,
N,
k_ave,
d_ave,
log(N) / log(k_ave),
c_ave,
k_ave / (N-1)
)
)
}
# データフレームの出力
names(df) <- c("Network","N","<k>","d_ave","d_ave_ER","C_ave","C_ave_ER")
df
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
c_ave_real
# モデルネットワーク
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
c_ave_rand
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
# コンフィギュレーションモデル
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
# 出力
cat("実際：",c_ave_real,"コンフィギュレーション："c_ave_real,"\n")
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
# コンフィギュレーションモデル
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
# 出力
cat("実際：",c_ave_real,"コンフィギュレーション：",c_ave_real,"\n")
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
# コンフィギュレーションモデル
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
# 出力
cat("実際：",c_ave_real,"コンフィギュレーション：",c_ave_rand,"\n")
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 仮想的な重みを追加する（対数正規分布由来の乱数を与える）
E(g)$weight <- rlnorm(ecount(g))
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
# 次数のベクトルを取得
deg <- degree(g)
g_rand <- degree.sequence.game(deg, method="vl")
plot(degree(g), degree(g_rand), xlab="k in real network", ylab="k in model network")
abline(0,1)
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
# コンフィギュレーションモデル
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
# 出力
cat("実際：",c_ave_real,"コンフィギュレーション：",c_ave_rand,"\n")
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
# コンフィギュレーションモデル
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
# 出力
cat("実際：",c_ave_real,"コンフィギュレーション：",c_ave_rand,"\n")
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
# コンフィギュレーションモデル
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
# 出力
cat("実際：",c_ave_real,"コンフィギュレーション：",c_ave_rand,"\n")
# igraphパッケージの読み込み
library(igraph)
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
cc_real <- transitivity(g, type="localaverage", isolates="zero")
apl_real <- mean_distance(g)
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次の三つからひとつを選ぶ）
# 1) Edge switching algorithm (simple version)
g_null <- rewire(g, with=keeping_degseq(niter=ecount(g)*(50+log(ecount(g)))/2,loops=F))
# 2) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
#g_null <- edge_swapping_randomization(g)
# 3) Configuration model
#g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:300){
# ランダムネットワークの作成（次のふたつからひとつを選ぶ）
# 1) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
g_null <- edge_swapping_randomization(g)
# 2) Configuration model
#g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次のふたつからひとつを選ぶ）
# 1) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
g_null <- edge_swapping_randomization(g)
# 2) Configuration model
#g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real))
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real))
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 平均クラスタ係数に対するP値（両側）
2 * pnorm(-abs(z_cc))
# 平均最短経路に対するP値（両側）
2 * pnorm(-abs(z_apl))
# 平均クラスタ係数に対するP値（上側）
length(cc_null[cc_null > cc_real]) / length(cc_null)
# 平均最短経路に対するP値（上側）
length(apl_null[apl_null > apl_real]) / length(apl_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
cc_real <- transitivity(g, type="localaverage", isolates="zero")
apl_real <- mean_distance(g)
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次のふたつからひとつを選ぶ）
# 1) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
# ランダム化ネットワーク
g_null <- edge_swapping_randomization(g)
# 2) コンフィギュレーションモデル（代わりにこちらを使うこともできる）
#g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real))
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real))
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 平均クラスタ係数に対するP値（両側）
2 * pnorm(-abs(z_cc))
# 平均最短経路に対するP値（両側）
2 * pnorm(-abs(z_apl))
# 平均クラスタ係数に対するP値（上側）
length(cc_null[cc_null > cc_real]) / length(cc_null)
# 平均最短経路に対するP値（上側）
length(apl_null[apl_null > apl_real]) / length(apl_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
# 次数のベクトルを取得
deg <- degree(g)
g_rand <- degree.sequence.game(deg, method="vl")
plot(degree(g), degree(g_rand), xlab="k in real network", ylab="k in model network")
abline(0,1)
# 実際のネットワーク
c_ave_real <- transitivity(g,type="localaverage",isolates="zero")
# コンフィギュレーションモデル
c_ave_rand <- transitivity(g_rand,type="localaverage",isolates="zero")
# 出力
cat("実際：",c_ave_real,"コンフィギュレーション：",c_ave_rand,"\n")
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
# 大腸菌のタンパク質相互作用ネットワークの次数分布のプロット
k <- 0:max(degree(g))
plot(k, degree.distribution(g), xlab="k", ylab="P(k)", log="xy")
# Erdos-Renyiのランダムネットワークの次数分布の理論式：式(3.2)
f <- function(k,N,p){
return(choose(N-1,k) * p**k * (1-p)**(N-1-k))
}
# 理論線の描画
N <- vcount(g)
p <- mean(degree(g)) / (N-1)
lines(k, f(k, N, p))
# erdos.renyi.game(N, p)
g <- erdos.renyi.game(10, 0.2)
# 描画
plot(g, layout=layout_in_circle)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real))
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), xlab="<C>"))
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real), xlab="<C>")
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real), xlab="<d>")
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 平均クラスタ係数に対するP値（両側）
2 * pnorm(-abs(z_cc))
# 平均最短経路に対するP値（両側）
2 * pnorm(-abs(z_apl))
# 平均クラスタ係数に対するP値（上側）
length(cc_null[cc_null > cc_real]) / length(cc_null)
# 平均最短経路に対するP値（上側）
length(apl_null[apl_null > apl_real]) / length(apl_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real), xlab="<C>", m="")
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real), xlab="<d>", m="")
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次のふたつからひとつを選ぶ）
# 1) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
# ランダム化ネットワーク
#g_null <- edge_swapping_randomization(g)
# 2) コンフィギュレーションモデル（代わりにこちらを使うこともできる）
g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real), xlab="<C>", m="")
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次のふたつからひとつを選ぶ）
# 1) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
# ランダム化ネットワーク
#g_null <- edge_swapping_randomization(g)
# 2) コンフィギュレーションモデル（代わりにこちらを使うこともできる）
g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
cc_real <- transitivity(g, type="localaverage", isolates="zero")
apl_real <- mean_distance(g)
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次のふたつからひとつを選ぶ）
# 1) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
# ランダム化ネットワーク
#g_null <- edge_swapping_randomization(g)
# 2) コンフィギュレーションモデル（代わりにこちらを使うこともできる）
g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real), xlab="<C>", m="")
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real), xlab="<d>", m="")
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 平均クラスタ係数に対するP値（両側）
2 * pnorm(-abs(z_cc))
# 平均最短経路に対するP値（両側）
2 * pnorm(-abs(z_apl))
# 平均クラスタ係数に対するP値（上側）
length(cc_null[cc_null > cc_real]) / length(cc_null)
# 平均最短経路に対するP値（上側）
length(apl_null[apl_null > apl_real]) / length(apl_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次のふたつからひとつを選ぶ）
# 1) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
# ランダム化ネットワーク
g_null <- edge_swapping_randomization(g)
# 2) コンフィギュレーションモデル（代わりにこちらを使うこともできる）
#g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real), xlab="<C>", m="")
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real), xlab="<d>", m="")
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 平均クラスタ係数に対するP値（両側）
2 * pnorm(-abs(z_cc))
# 平均最短経路に対するP値（両側）
2 * pnorm(-abs(z_apl))
# 平均クラスタ係数に対するP値（上側）
length(cc_null[cc_null > cc_real]) / length(cc_null)
# 平均最短経路に対するP値（上側）
length(apl_null[apl_null > apl_real]) / length(apl_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
