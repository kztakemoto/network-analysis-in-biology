# igraphパッケージの読み込み
library(igraph)
# 空手クラブのネットワークを（無向きなしネットワークで）読み込む
g <- as.undirected(read.graph("../data/karate.GraphML",format="graphml"))
# エッジの重みを無効にする（ここでは使わないため）
if(!is.null(get.edge.attribute(g,"weight"))) g <- delete_edge_attr(g, "weight")
# 隣接行列（Aij）を得る
A_ij <- get.adjacency(g,sparse=F)
# Jijの計算
J_ij <- cocitation(g)
# min(ki,kj)の計算
deg <- degree(g)
deg_mtx <- matrix(0,nrow=vcount(g),ncol=vcount(g))
for(i in 1:vcount(g)){
for(j in 1:vcount(g)){
deg_mtx[i,j] <- min(deg[[i]],deg[[j]])
}
}
# Topological overlap score matrixを得る
overlap_mtx <- (J_ij + A_ij) / (deg_mtx + 1 - A_ij)
diag(overlap_mtx) <- 1
# 距離行列(dissimilarity score matrix)に変換
dist <- as.dist(1 - overlap_mtx)
# 群平均法に基づいて階層的クラスタリング
res <- hclust(dist, method="average")
# デンドログラムをプロット
plot(res)
# heightに対する適当な閾値hでコミュニティを決める場合
# mem <- cutree(res, h=0.9)
# k個数のコミュニティになるように分割する場合（ここでは2個に設定）
mem <- cutree(res, k=2)
mem
# コミュニティのメンバシップにしたがってノードを色付け
V(g)$color <- mem
# ネットワークを描画。ノードの形が実際のメンバーシップに対応します。
plot(g,vertex.size=10, vertex.label=V(g)$name, vertex.shape=c("circle","square")[V(g)$Faction])
# パッケージの読み込み
library(igraph)
library(rnetcarto)
# パッケージの読み込み
library(igraph)
library(rnetcarto)
# 空手クラブのネットワークを（無向きなしネットワークで）読み込む
g <- as.undirected(read.graph("../data/karate.GraphML",format="graphml"))
# エッジの重みを無効にする（ここでは使わないため）
if(!is.null(get.edge.attribute(g,"weight"))) g <- delete_edge_attr(g, "weight")
# アルゴリズムの実行
data <- cluster_fast_greedy(g)
# メンバーシップの表示
data$membership
# デンドログラムの表示
dendPlot(data)
# コミュニティ検出の結果
plot(data, g)
# アルゴリズムの実行
data <- cluster_leading_eigen(g,options=list(maxiter=1000000, ncv=5))
# メンバーシップの表示
data$membership
# デンドログラムの表示
dendPlot(data)
# コミュニティ検出の結果
plot(data, g)
# デンドログラムの表示
dendPlot(data)
# コミュニティ検出の結果
plot(data, g)
# デンドログラムの表示
dendPlot(data)
# コミュニティ検出の結果
plot(data, g)
# アルゴリズムの実行
data <- cluster_leading_eigen(g,options=list(maxiter=1000000, ncv=5))
# メンバーシップの表示
data$membership
# デンドログラムをプロット
dendPlot(data)
# コミュニティ検出の結果
plot(data, g)
# 隣接行列を取得
mtx <- get.adjacency(g, sparse=F)
# コミュニティ抽出を実行
res <- netcarto(mtx)
# 出力結果
res
# igraphの出力結果と一致するように出力を調整
table <- as.data.frame(res[[1]])
table$module <- table$module + 1
row.names(table) <- table$name
table <- table[V(g)$name,]
data <- list(membership = table$module, modularity=c(res[[2]]))
# ネットワークを表示
V(g)$community <- data$membership
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen"), alpha=.6) # 色付け
plot(g, vertex.color=colrs[V(g)$community])
table$role
# パッケージの読み込み
library(igraph)
library(linkcomm)
# 空手クラブのネットワークを（無向きなしネットワークで）読み込む
g <- as.undirected(read.graph("../data/karate.GraphML",format="graphml"))
# エッジの重みを無効にする（ここでは使わないため）
if(!is.null(get.edge.attribute(g,"weight"))) g <- delete_edge_attr(g, "weight")
# 後のわかりやすさのためノードに実際のコミュニティ番号を追加
V(g)$name <- paste(V(g)$name,V(g)$Faction,sep=":")
# エッジリストを取得
el <- get.edgelist(g)
# スペースをアンダーバーに置き換え（linkcommパッケージはスペースを許さない）
el <- gsub(" ","_",el)
# ここでは階層的クラスタリングにおいて群平均法を使用
linkcomm <- getLinkCommunities(el, hcmethod="average", use.all.edges=T)
plot(linkcomm, type="graph")
plot(linkcomm, type="members")
linkcomm_at <- newLinkCommsAt(linkcomm, cutat=0.9)
plot(ocg, type="graph")
plot(ocg, type="graph")
ocg <- getOCG.clusters(el)
plot(ocg, type="graph")
#ひとつのコミュニティのみに属すエッジは出力されないことに注意。
plot(ocg, type="members")
