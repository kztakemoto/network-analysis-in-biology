# 次数の計算（configuration modelのため）
deg <- degree(g)
# igraphパッケージの読み込み
library(igraph)
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
cc_real <- transitivity(g, type="localaverage", isolates="zero")
apl_real <- mean_distance(g)
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:10){
# ランダムネットワークの作成（次の三つからひとつを選ぶ）
# 1) Edge switching algorithm (simple version)
#g_null <- rewire(g, with=keeping_degseq(niter=ecount(g)*(50+log(ecount(g)))/2,loops=F))
# 2) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
g_null <- edge_swapping_randomization(g)
# 3) Configuration model
#g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:10){
# ランダムネットワークの作成（次の三つからひとつを選ぶ）
# 1) Edge switching algorithm (simple version)
g_null <- rewire(g, with=keeping_degseq(niter=ecount(g)*(50+log(ecount(g)))/2,loops=F))
# 2) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
#g_null <- edge_swapping_randomization(g)
# 3) Configuration model
#g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
cat("平均クラスタ係数に対するP値（両側）\n")
2 * pnorm(-abs(z_cc))
cat("平均最短経路に対するP値（両側）\n")
2 * pnorm(-abs(z_apl))
cc_real * mean(apl_null) / apl_real / mean(cc_null)
dist(cc_null)
hist(cc_null)
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次の三つからひとつを選ぶ）
# 1) Edge switching algorithm (simple version)
#g_null <- rewire(g, with=keeping_degseq(niter=ecount(g)*(50+log(ecount(g)))/2,loops=F))
# 2) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
#g_null <- edge_swapping_randomization(g)
# 3) Configuration model
g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
hist(cc_null)
hist(cc_null, xlim=c(min(cc_null), cc_real))
hist(cc_null, xlim=c(min(cc_null), cc_real))
abline(v=cc_real)
hist(cc_null, xlim=c(min(cc_null), cc_real))
abline(v=cc_real, col="red")
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real))
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real))
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 平均クラスタ係数に対するP値（両側）
2 * pnorm(-abs(z_cc))
# 平均最短経路に対するP値（両側）
2 * pnorm(-abs(z_apl))
cc_real * mean(apl_null) / apl_real / mean(cc_null)
# 平均クラスタ係数に対するP値（上側）
length(cc_null[cc_null > cc_real]) / length(cc_null)
# 平均最短経路に対するP値（上側）
length(apl_null[apl_null > apl_real]) / length(apl_null)
# igraphパッケージの読み込み
library(igraph)
# エッジリストの読み込み
d <- read.table("../data/ecoli_ppi_Hu_etal_2009.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
cc_real <- transitivity(g, type="localaverage", isolates="zero")
apl_real <- mean_distance(g)
# 次数の計算（configuration modelのため）
deg <- degree(g)
# ランダムネットワークの平均クラスタ係数を格納するための配列
cc_null <- c()
# ランダムネットワークの平均最短経路長を格納するための配列
apl_null <- c()
for(i in 1:100){
# ランダムネットワークの作成（次の三つからひとつを選ぶ）
# 1) Edge switching algorithm (simple version)
#g_null <- rewire(g, with=keeping_degseq(niter=ecount(g)*(50+log(ecount(g)))/2,loops=F))
# 2) Edge switching algorithm [R. Milo et al., Science 298, 824 (2002)] doi:10.1126/science.298.5594.824
#g_null <- edge_swapping_randomization(g)
# 3) Configuration model
g_null <- degree.sequence.game(deg,m="vl")
# 平均クラスタ係数
cc_null <- c(cc_null, transitivity(g_null, type="localaverage", isolates="zero"))
# 平均最短経路長
apl_null <- c(apl_null, mean_distance(g_null))
}
# 平均クラスタ係数
z_cc <- (cc_real - mean(cc_null)) / sd(cc_null)
# 平均最短経路長
z_apl <- (apl_real - mean(apl_null)) / sd(apl_null)
# ヒストグラム
hist(cc_null, xlim=c(min(cc_null), cc_real))
# 観測値を赤線で示す
abline(v=cc_real, col="red")
# ヒストグラム
hist(apl_null, xlim=c(min(apl_null), apl_real))
# 観測値を赤線で示す
abline(v=apl_real, col="red")
# 平均クラスタ係数に対するP値（両側）
2 * pnorm(-abs(z_cc))
# 平均最短経路に対するP値（両側）
2 * pnorm(-abs(z_apl))
# 平均クラスタ係数に対するP値（上側）
length(cc_null[cc_null > cc_real]) / length(cc_null)
# 平均最短経路に対するP値（上側）
length(apl_null[apl_null > apl_real]) / length(apl_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
cc_real * mean(apl_null) / apl_real / mean(cc_null)
# igraphパッケージの読み込み
library(igraph)
# エッジリストの読み込み
d <- read.table("../data/ecoli_regDB5.txt")
# グラフオブジェクトの作成（有向ネットワークで読み込む）
g <- simplify(graph.data.frame(d,directed=T),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
motif_real <- motifs(g,3)
motif_rand <- c()
for(i in 1:100){
g_rand <- edge_swapping_randomization(g)
motif_rand <- rbind(motif_rand, motifs(g_rand,3))
}
# データフレームに変換
motif_rand <- as.data.frame(motif_rand)
z_motif <- (motif_real - apply(motif_rand, 2 ,mean)) / apply(motif_rand, 2 ,sd)
# わかりやすいように名前をわり当てる
names(z_motif) <- paste("motif_3_",0:15,sep="")
z_motif
# motif_3_7 の構造は次のようにして知ることができる。
plot(graph.isocreate(3,7), layout=layout.circle)
# motif_3_3: Chain
# motif_3_7: Feedforward loop (FFL)
# motif_3_11: Feedback loop (FBL)
p_motif
p_motif <- 2 * pnorm(-abs(z_motif))
p_motif
# 例としてfeedforward loop (motif_3_7)をみてみる。
graph.get.subisomorphisms.vf2(g,graph.isocreate(3,7))
z_motif_na_omit <- c(na.omit(z_motif)) # NAを削除
tsp <- z_motif_na_omit / sqrt(sum(z_motif_na_omit**2))
barplot(tsp, las=2)
# 相対部分ネットワーク比の計算
tsr_motif <- (motif_real - apply(motif_rand, 2, mean)) / (motif_real + apply(motif_rand, 2, mean) + 4)
# わかrやすいようにモチーフのIDを割り振る
names(tsr_motif) <- paste("motif_3_",0:15,sep="")
# NAを削除する
tsr_motif_na_omit <- c(na.omit(tsr_motif))
# 標準化
tsrp_motif <- tsr_motif_na_omit / sqrt(sum(tsr_motif_na_omit**2))
barplot(tsrp_motif, las=2)
# igraphパッケージの読み込み
library(igraph)
# ノード数
N <- 1000
# エッジの数は2000から10000まで200ずつ増加させていく。
L_seq <- seq(2000, 10000, by=200)
nb_ffl_real <- c() # feedforward loop (FFL) の実際の数（観測値）が格納される
nb_ffl_theory <- c() # 近似式から推定されたFFLの数（予測値）が格納される
nb_fbl_real <- c()  # feedback loop (FBL) の実際の数（観測値）が格納される
nb_fbl_theory <- c() # 近似式から推定されたFBLの数（予測値）が格納される
for(L in L_seq){
# Chung-Luモデルネットワークの作成
g <- static.power.law.game(N, L, 2.1, 2.1)
# 単方向エッジのみのネットワークを作成
g_one_way <- delete_edges(g, E(g)[which_mutual(g)==T])
# 双方向エッジのみのネットワークを作成
g_mutual <- delete_edges(g, E(g)[which_mutual(g)==F])
# 各ノードの双方向エッジの数を得る
M <- degree(g_mutual, mode="out")
# 各ノードの単方向の出力エッジの数を得る
K <- degree(g_one_way, mode="out")
# 各ノードの単方向の入力エッジの数を得る
R <- degree(g_one_way, mode="in")
# 3ノード部分ネットワークをカウントする
motif_real <- motifs(g, 3)
# FFLの観測値を得る
nb_ffl_real <- c(nb_ffl_real, motif_real[[8]])
# FBLの観測値を得る
nb_fbl_real <- c(nb_fbl_real, motif_real[[12]])
# FFLの予測値を得る
nb_ffl_theory <- c(nb_ffl_theory, mean(K*(K-1)) * mean(K*R) * mean(R*(R-1)) / mean(K)**3)
# FBLの予測値を得る
nb_fbl_theory <- c(nb_fbl_theory, mean(K*R)**3 / mean(K)**3 / 3)
}
layout(matrix(1:2, ncol=2))
# FFL
plot(nb_ffl_real, nb_ffl_theory)
abline(0,1) # 対角線の追加
# FBL
plot(nb_fbl_real, nb_fbl_theory)
abline(0,1) # 対角線の追加
