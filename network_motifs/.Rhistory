# igraphパッケージの読み込み
library(igraph)
# エッジリストの読み込み
d <- read.table("../data/ecoli_regDB5.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
motif_real <- motifs(g,3)
# igraphパッケージの読み込み
library(igraph)
# エッジリストの読み込み
d <- read.table("../data/ecoli_regDB5.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
motif_real <- motifs(g,3)
motif_rand <- c()
for(i in 1:100){
g_rand <- edge_swapping_randomization(g)
motif_rand <- rbind(motif_rand, motifs(g_rand,3))
}
motif_rand <- c()
for(i in 1:100){
g_rand <- edge_swapping_randomization(g)
motif_rand <- rbind(motif_rand, motifs(g_rand,3))
}
# データフレームに変換
motif_rand <- as.data.frame(motif_rand)
z_motif <- (motif_real - apply(motif_rand, 2 ,mean)) / apply(motif_rand, 2 ,sd)
# わかりやすいように名前をわり当てる
names(z_motif) <- paste("motif_3_",0:15,sep="")
z_motif <- (motif_real - apply(motif_rand, 2 ,mean)) / apply(motif_rand, 2 ,sd)
# わかりやすいように名前をわり当てる
names(z_motif) <- paste("motif_3_",0:15,sep="")
z_motif <- (motif_real - apply(motif_rand, 2 ,mean)) / apply(motif_rand, 2 ,sd)
# わかりやすいように名前をわり当てる
names(z_motif) <- paste("motif_3_",0:15,sep="")
z_motif <- (motif_real - apply(motif_rand, 2 ,mean)) / apply(motif_rand, 2 ,sd)
z_motif
# わかりやすいように名前をわり当てる
names(z_motif) <- paste("motif_3_",0:15,sep="")
motif_rand
motif_real
# エッジリストの読み込み
d <- read.table("../data/ecoli_regDB5.txt")
# グラフオブジェクトの作成
g <- simplify(graph.data.frame(d,directed=T),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
# エッジリストの読み込み
d <- read.table("../data/ecoli_regDB5.txt")
# グラフオブジェクトの作成（有向ネットワークで読み込む）
g <- simplify(graph.data.frame(d,directed=T),remove.multiple=T,remove.loops=T)
# 最大連結成分の取得
cls <- clusters(g,"weak")
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
source("../src/edge_swapping_randomization.R")
motif_real <- motifs(g,3)
motif_real
motif_rand <- c()
for(i in 1:100){
g_rand <- edge_swapping_randomization(g)
motif_rand <- rbind(motif_rand, motifs(g_rand,3))
}
# データフレームに変換
motif_rand <- as.data.frame(motif_rand)
motif_rand
z_motif <- (motif_real - apply(motif_rand, 2 ,mean)) / apply(motif_rand, 2 ,sd)
z_motif
# わかりやすいように名前をわり当てる
names(z_motif) <- paste("motif_3_",0:15,sep="")
z_motif <- (motif_real - apply(motif_rand, 2 ,mean)) / apply(motif_rand, 2 ,sd)
# わかりやすいように名前をわり当てる
names(z_motif) <- paste("motif_3_",0:15,sep="")
z_motif
# motif_3_7 の構造は次のようにして知ることができる。
plot(graph.isocreate(3,7), layout=layout.circle)
p_motif <- 2 * pnorm(-abs(z_motif))
p_motif
# 例としてfeedforward loop (motif_3_7)をみてみる。
graph.get.subisomorphisms.vf2(g,graph.isocreate(3,7))
z_motif_na_omit <- c(na.omit(z_motif)) # NAを削除
tsp <- z_motif_na_omit / sqrt(sum(z_motif_na_omit**2))
barplot(tsp, las=2)
# コミュニティのメンバシップにしたがってノードを色付け
tsr_motif <- (motif_real - apply(motif_rand, 2, mean)) / (motif_real + apply(motif_rand, 2, mean) + 4)
tsr_motif
# 相対部分ネットワーク比の計算
tsr_motif <- (motif_real - apply(motif_rand, 2, mean)) / (motif_real + apply(motif_rand, 2, mean) + 4)
# わかrやすいようにモチーフのIDを割り振る
names(tsr_motif) <- paste("motif_3_",0:15,sep="")
# NAを削除する
tsr_motif_na_omit <- c(na.omit(tsr_motif))
# 標準化
tsrp_motif <- tsr_motif_na_omit / sqrt(sum(tsr_motif_na_omit**2))
barplot(tsrp_motif, las=2)
# igraphパッケージの読み込み
library(igraph)
# ノード数
N <- 1000
# エッジの数は2000から10000まで200ずつ増加させていく。
L_seq <- seq(2000, 10000, by=200)
nb_ffl_real <- c() # feedforward loop (FFL) の実際の数（観測値）が格納される
nb_ffl_theory <- c() # 近似式から推定されたFFLの数（予測値）が格納される
nb_fbl_real <- c()  # feedback loop (FBL) の実際の数（観測値）が格納される
nb_fbl_theory <- c() # 近似式から推定されたFBLの数（予測値）が格納される
for(L in L_seq){
# Chung-Luモデルネットワークの作成
g <- static.power.law.game(N, L, 2.1, 2.1)
# 単方向エッジのみのネットワークを作成
g_one_way <- delete_edges(g, E(g)[which_mutual(g)==T])
# 双方向エッジのみのネットワークを作成
g_mutual <- delete_edges(g, E(g)[which_mutual(g)==F])
# 各ノードの双方向エッジの数を得る
M <- degree(g_mutual, mode="out")
# 各ノードの単方向の出力エッジの数を得る
K <- degree(g_one_way, mode="out")
# 各ノードの単方向の入力エッジの数を得る
R <- degree(g_one_way, mode="in")
# 3ノード部分ネットワークをカウントする
motif_real <- motifs(g, 3)
# FFLの観測値を得る
nb_ffl_real <- c(nb_ffl_real, motif_real[[8]])
# FBLの観測値を得る
nb_fbl_real <- c(nb_fbl_real, motif_real[[12]])
# FFLの予測値を得る
nb_ffl_theory <- c(nb_ffl_theory, mean(K*(K-1)) * mean(K*R) * mean(R*(R-1)) / mean(K)**3)
# FBLの予測値を得る
nb_fbl_theory <- c(nb_fbl_theory, mean(K*R)**3 / mean(K)**3 / 3)
}
layout(matrix(1:2, ncol=2))
plot(nb_ffl_real, nb_ffl_theory)
abline(0,1)
plot(nb_fbl_real, nb_fbl_theory)
abline(0,1)
layout(matrix(1:2, ncol=2))
# FFL
plot(nb_ffl_real, nb_ffl_theory)
abline(0,1) # 対角線の追加
# FBL
plot(nb_fbl_real, nb_fbl_theory)
abline(0,1) # 対角線の追加
